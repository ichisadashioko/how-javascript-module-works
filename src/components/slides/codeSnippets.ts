export const nodeJsImportPseudoCode = `require(X) from module at path Y\n1. If X is a core module,\n   a. return the core module\n   b. STOP\n2. If X begins with \'/\'\n   a. set Y to be the filesystem root\n3. If X begins with \'./\' or \'/\' or \'../\'\n   a. LOAD_AS_FILE(Y + X)\n   b. LOAD_AS_DIRECTORY(Y + X)\n   c. THROW "not found"\n4. LOAD_NODE_MODULES(X, dirname(Y))\n5. LOAD_SELF_REFERENCE(X, dirname(Y))\n6. THROW "not found"\n\nLOAD_AS_FILE(X)\n1. If X is a file, load X as JavaScript text.  STOP\n2. If X.js is a file, load X.js as JavaScript text.  STOP\n3. If X.json is a file, parse X.json to a JavaScript Object.  STOP\n4. If X.node is a file, load X.node as binary addon.  STOP\n\nLOAD_INDEX(X)\n1. If X/index.js is a file, load X/index.js as JavaScript text.  STOP\n2. If X/index.json is a file, parse X/index.json to a JavaScript object. STOP\n3. If X/index.node is a file, load X/index.node as binary addon.  STOP\n\nLOAD_AS_DIRECTORY(X)\n1. If X/package.json is a file,\n   a. Parse X/package.json, and look for "main" field.\n   b. If "main" is a falsy value, GOTO 2.\n   c. let M = X + (json main field)\n   d. LOAD_AS_FILE(M)\n   e. LOAD_INDEX(M)\n   f. LOAD_INDEX(X) DEPRECATED\n   g. THROW "not found"\n2. LOAD_INDEX(X)\n\nLOAD_NODE_MODULES(X, START)\n1. let DIRS = NODE_MODULES_PATHS(START)\n2. for each DIR in DIRS:\n   a. LOAD_AS_FILE(DIR/X)\n   b. LOAD_AS_DIRECTORY(DIR/X)\n\nNODE_MODULES_PATHS(START)\n1. let PARTS = path split(START)\n2. let I = count of PARTS - 1\n3. let DIRS = [GLOBAL_FOLDERS]\n4. while I >= 0,\n   a. if PARTS[I] = "node_modules" CONTINUE\n   b. DIR = path join(PARTS[0 .. I] + "node_modules")\n   c. DIRS = DIRS + DIR\n   d. let I = I - 1\n5. return DIRS\n\nLOAD_SELF_REFERENCE(X, START)\n1. Find the closest package scope to START.\n2. If no scope was found, throw "not found".\n3. If the name in \`package.json\` isn\'t a prefix of X, throw "not found".\n4. Otherwise, resolve the remainder of X relative to this package as if it\n   was loaded via \`LOAD_NODE_MODULES\` with a name in \`package.json\`.`

export const dojoDefineExample = `define([\n    // The dojo/dom module is required by this module, so it goes\n    // in this list of dependencies.\n    'dojo/dom'\n], function (dom) {\n    // Once all modules in the dependency list have loaded, this\n    // function is called to define the demo/myModule module.\n    //\n    // The dojo/dom module is passed as the first argument to this\n    // function; additional modules in the dependency list would be\n    // passed in as subsequent arguments.\n\n    var oldText = {};\n\n    // This returned object becomes the defined value of this module\n    return {\n        setText: function (id, text) {\n            var node = dom.byId(id);\n            oldText[id] = node.innerHTML;\n            node.innerHTML = text;\n        },\n\n        restoreText: function (id) {\n            var node = dom.byId(id);\n            node.innerHTML = oldText[id];\n            delete oldText[id];\n        }\n    };\n})`

export const dojoDefine = `var def = function(\n    mid,          //(commonjs.moduleId, optional)\n    dependencies, //(array of commonjs.moduleId, optional) list of modules to be loaded before running factory\n    factory       //(any)\n){...}`

export const dojoRequire = `req = function(\n    config,       //(object, optional) hash of configuration properties\n    dependencies, //(array of commonjs.moduleId, optional) list of modules to be loaded before applying callback\n    callback\t  //(function, optional) lambda expression to apply to module values implied by dependencies\n){...}`

export const dojoRequireExample = `require([\n    'dojo/dom',\n    'dojo/dom-construct'\n], function (dom, domConstruct) {\n    var greetingNode = dom.byId('greeting');\n    domConstruct.place('<em> Dojo!</em>', greetingNode);\n});`